# License : Apache-2.0
# Copyright(c) 2020 Selfie Networks, Inc

# A BESS pipeline that can be used as a Geneve proxy

from socket import htons

MAC_ADDR = '02:dc:ab:f6:6c:16'
IP_ADDR = '172.16.0.62'
IP_MASK = 25
GENEVE_PORT = 6081
HEALTH_CHECK_PORT = 9000

# NTF Configuration
ntf::NTF(dpid=1)

# DPDK Port Configuration
mac_address = int(MAC_ADDR.replace(':', ''), 16)

dpdk_port = PMDPort(port_id=0)
dpdk_in = QueueInc(port=dpdk_port)
dpdk_out = Update(fields=[
    {'offset': 6, 'size': 6, 'value': mac_address }
]) 

# Handle packets from the Geneve tunnel
matchGeneve = ExactMatch(fields=[
  {'offset': 23, 'num_bytes': 1}, # Proto
  {'offset': 36, 'num_bytes': 2}, # Dest port
])
matchGeneve.set_default_gate(gate=0)
matchGeneve.add(fields=[
  {'value_int': 17},                 # UDP
  {'value_int': htons(GENEVE_PORT)}, # Geneve
], gate=1)

geneveDecap = GeneveDecap()
geneveReturn = GeneveReturn()

# ARP responder
matchARP = ExactMatch(fields=[
  {'offset': 12, 'num_bytes': 2}, # Ether Type
])
matchARP.set_default_gate(gate=0)
matchARP.add(fields=[
    {'value_int': htons(0x0806) # ARP
}], gate=1)
arpResponder = ArpResponder()
arpResponder.add(ip=IP_ADDR, mac_addr=MAC_ADDR)

# Health check
matchHealthcheck::ExactMatch(fields=[
  {'offset': 23, 'num_bytes': 1}, # Proto
  {'offset': 36, 'num_bytes': 2}, # Dest port
])
matchHealthcheck.set_default_gate(gate=0)
matchHealthcheck.add(fields=[
  {'value_int': 6},                        # TCP
  {'value_int': htons(HEALTH_CHECK_PORT)}, # SSH
], gate=1)
healthcheckResponder = HealthcheckResponder()

# NTF: Token Detection
detectToken = TokenDetector(
    token_insert="GENEVE",
    geneve_option_class=0xB00F,
    geneve_option_type=0x2A,
)

decryptToken = TokenDecryptor(
    shared_key='5db7b4f17ad7eec0b49ec655c61ac3c8',
)

# Construct the pipeline
dpdk_in -> matchGeneve:0 -> matchARP:0 -> matchHealthcheck:0 -> Sink()

matchGeneve:1 -> geneveDecap:1 -> detectToken:1 -> decryptToken:1 -> geneveReturn

geneveDecap:0 -> decapFail::Sink()
detectToken:0 -> noToken::Sink()
decryptToken:0 -> badToken::Sink()

matchARP:1 -> arpResponder -> dpdk_out

matchHealthcheck:1 -> healthcheckResponder -> dpdk_out

geneveReturn -> dpdk_out

dpdk_out -> QueueOut(port=dpdk_port)
