# License : Apache-2.0
# Copyright(c) 2020 Selfie Networks, Inc

# A BESS pipeline that can be used as a Geneve proxy

from binascii import unhexlify
from socket import htons


#==============================================================================
# Host Configuration
#----------------------------------------------------------------------------- 

MAC_ADDR = '02:dc:ab:f6:6c:16'
IP_ADDR = '172.16.0.62'

GENEVE_PORT = 6081
HEALTH_CHECK_PORT = 9000


#==============================================================================
# Geneve Proxy Pipeline
#----------------------------------------------------------------------------- 

# DPDK Port Configuration
dpdk_port::PMDPort(port_id=0)

# Configure input & output queues
dpdk_in::QueueInc(port=dpdk_port)
dpdk_out::QueueOut(port=dpdk_port)

# Update the MAC address
outgoing::Update(fields=[
    {'offset': 6, 'size': 6, 'value': int(MAC_ADDR.replace(':', ''), 16)}
]) 

# Handle packets from the Geneve tunnel
matchGeneve::ExactMatch(fields=[
    {'offset': 23, 'num_bytes': 1}, # Proto
    {'offset': 36, 'num_bytes': 2}, # Dest port
])
matchGeneve.set_default_gate(gate=0)
matchGeneve.add(fields=[
    {'value_int': 17},                 # UDP
    {'value_int': htons(GENEVE_PORT)}, # Geneve
], gate=1)

geneveDecap::GeneveDecap()
geneveReturn::GeneveReturn()

# ARP responder
matchARP::ExactMatch(fields=[
    {'offset': 12, 'num_bytes': 2}, # Ether Type
])
matchARP.set_default_gate(gate=0)
matchARP.add(fields=[
    {'value_int': htons(0x0806) # ARP
}], gate=1)
arpResponder::ArpResponder()
arpResponder.add(ip=IP_ADDR, mac_addr=MAC_ADDR)

# Health check
matchHealthcheck::ExactMatch(fields=[
    {'offset': 23, 'num_bytes': 1}, # Proto
    {'offset': 36, 'num_bytes': 2}, # Dest port
])
matchHealthcheck.set_default_gate(gate=0)
matchHealthcheck.add(fields=[
    {'value_int': 6},                        # TCP
    {'value_int': htons(HEALTH_CHECK_PORT)}, # SSH
], gate=1)
healthcheckResponder::HealthcheckResponder()

# A sink for packets we don't care about
ignored::Sink()


#==============================================================================
# Network Token Function Pipeline
#----------------------------------------------------------------------------- 

# Decrypt tokens in Geneve tunnel ID
detectToken::TokenDetector(
    token_insert="GENEVE",
    geneve_option_class=0xB00F,
    geneve_option_type=0x2A,
)

# Decrypt tokens using a pre-shared key
decryptToken::TokenDecryptor(
    shared_key=unhexlify('b6415a67a0633cbae1a8c05239686eb4'),
    fields=[
        {'name': 'bip', 'type': 'IPV4'},
        {'name': 'sid', 'type': 'INT'},
        {'name': 'exp', 'type': 'INT'},
    ],
)

# Validate bound IP address & expiry
validateToken::TokenValidator()

# Fast-path for flows that have already matched a token
allowList::AllowList()

#==============================================================================
# Pipeline
#----------------------------------------------------------------------------- 

# Main pipeline - try to match interesting traffic, then ignore
dpdk_in \
    -> matchGeneve:0 \
    -> matchARP:0 \
    -> matchHealthcheck:0 \
    -> ignored

# Geneve Proxy pipeline
matchGeneve:1 \
    -> geneveDecap:1 \
    -> 0:allowList:0 \
    -> detectToken:1 \
    -> decryptToken:1 \
    -> validateToken:1 \
    -> 1:allowList:1 \
    -> geneveReturn \
    -> outgoing

# ARP pipeline
matchARP:1 \
    -> arpResponder \
    -> outgoing

# Healthcheck pipeline
matchHealthcheck:1 \
    -> healthcheckResponder \
    -> outgoing

# Outgoing pipeline - update src MAC address
outgoing \
    -> dpdk_out

# Ignore disqualified traffic
geneveDecap:0 -> decapFail::Sink()
detectToken:0 -> noToken::Sink()
decryptToken:0 -> decryptFail::Sink()
validateToken:0 -> badToken::Sink()
