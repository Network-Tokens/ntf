# License : Apache-2.0
# Copyright(c) 2020 Selfie Networks, Inc

# A BESS pipeline that can be used as a Geneve proxy

from socket import htons

MAC_ADDR = '02:dc:ab:f6:6c:16'
IP_ADDR = '172.16.0.62'
IP_MASK = 25
GENEVE_PORT = 6081
HEALTH_CHECK_PORT = 9000

# NTF Configuration
ntf::NTF(dpid=1)

# DPDK Port Configuration
mac_address = int(MAC_ADDR.replace(':', ''), 16)

dpdk_port = PMDPort(port_id=0)
dpdk_in = QueueInc(port=dpdk_port)
dpdk_out = Update(fields=[
    {'offset': 6, 'size': 6, 'value': mac_address }
]) 

# A bucket for ignored packets
drop = Sink()

# Handle packets from the Geneve tunnel
tunnelCheck = ExactMatch(fields=[
  {'offset': 23, 'num_bytes': 1}, # Proto
  {'offset': 36, 'num_bytes': 2}, # Dest port
])
tunnelCheck.set_default_gate(gate=0)
tunnelCheck.add(fields=[
  {'value_int': 17},                 # UDP
  {'value_int': htons(GENEVE_PORT)}, # Geneve
], gate=1)

tunnelDecap = GeneveDecap()
tunnelDecap:0 -> drop

# tunnelReturn::ReverseAddress() -> IPChecksum() -> geneveOut::MACSwap()
tunnelReturn = GeneveReturn()

# ARP responder
arpCheck = ExactMatch(fields=[
  {'offset': 12, 'num_bytes': 2}, # Ether Type
])
arpCheck.set_default_gate(gate=0)
arpCheck.add(fields=[
    {'value_int': htons(0x0806) # ARP
}], gate=1)
arpResponder = ArpResponder()
arpResponder.add(ip=IP_ADDR, mac_addr=MAC_ADDR)

# Health check
healthCheck::ExactMatch(fields=[
  {'offset': 23, 'num_bytes': 1}, # Proto
  {'offset': 36, 'num_bytes': 2}, # Dest port
])
healthCheck.set_default_gate(gate=0)
healthCheck.add(fields=[
  {'value_int': 6},                        # TCP
  {'value_int': htons(HEALTH_CHECK_PORT)}, # SSH
], gate=1)

healthCheck:1 -> HealthcheckResponder() -> dpdk_out

# Construct the pipeline
dpdk_in -> tunnelCheck:0 -> arpCheck:0 -> healthCheck:0 -> drop

tunnelCheck:1 -> tunnelDecap:1 -> ntf -> tunnelReturn

arpCheck:1 -> arpResponder -> dpdk_out

tunnelReturn -> dpdk_out

dpdk_out -> QueueOut(port=dpdk_port)
